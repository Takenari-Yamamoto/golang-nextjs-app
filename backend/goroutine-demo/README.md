# ゴルーチンとは

ゴルーチン (Goroutine) は、Go 言語（Golang）で独自に実装された並行処理の仕組みです。軽量なスレッドのようなもので、Go 言語のランタイムシステムによって管理されます。ゴルーチンは、リソースを効率的に利用しながら、同時に複数のタスクを実行できるように設計されています。

ゴルーチンは以下の特徴があります。

軽量：ゴルーチンは、通常のオペレーティングシステムのスレッドよりもメモリ使用量が少なく、軽量です。そのため、何千、何万といった大量のゴルーチンを生成しても、システムに大きな負荷をかけることなく実行できます。

簡単な構文：Go 言語では、関数やメソッドの前に "go" キーワードを付けるだけで、その関数をゴルーチンとして実行できます。これにより、並行処理を簡単に実装することができます。

高速なコンテキストスイッチ：ゴルーチン間のコンテキストスイッチは非常に高速であり、オペレーティングシステムのスレッドよりも効率的です。

チャネルを使ったデータのやり取り：Go 言語では、チャネル（Channel）という仕組みが用意されており、ゴルーチン同士でデータのやり取りや同期を簡単に行うことができます。チャネルは、データの送受信が同期されており、デッドロックや競合状態の回避が容易です。

ゴルーチンは、Go 言語における強力な並行処理の仕組みであり、サーバーサイド開

## 実装方法

### ゴルーチンを使わない方法

```go
package main

import (
	"fmt"
	"time"
)

func square(n int) {
	fmt.Printf("Square of %d is %d\n", n, n*n)
}

func main() {
	// 順番に関数を実行
	square(2)
	square(4)
	square(6)

	// 順番に実行が終わるのを待つ
	time.Sleep(1 * time.Second)
}

```

### ゴルーチンを使った方法

```go
package main

import (
	"fmt"
	"time"
)

func square(n int) {
	fmt.Printf("Square of %d is %d\n", n, n*n)
}

func main() {
	// ゴルーチンを使って関数を実行
	go square(2)
	go square(4)
	go square(6)

	// ゴルーチンの実行が終わるのを待つ
	time.Sleep(1 * time.Second)
}
```

square() 関数の前に go キーワードを追加して、ゴルーチンとして実行しています。これにより、各 square() 関数が並行して実行されます。

ただし、ゴルーチンは非同期的に実行されるため、プログラムがすぐに終了してしまうと、ゴルーチンが完了する前にプログラムが終了してしまいます。そこで、time.Sleep() を使って、ゴルーチンが完了するのを待っています。ただし、実際のアプリケーションでは、time.Sleep() よりもチャネルを使ってゴルーチンの終了を待つ方法が一般的です。

## まとめ

- 軽量なスレッドのようなもので、Go 言語における並行処理の基本単位です。
- スレッドに比べてメモリ消費が少なく、数百万個のゴルーチンを同時に実行することが可能です。
- Go ランタイムが管理し、スケジューリングを効率的に行うため、OS スレッドよりも高速に実行されることがあります。
- ゴルーチン間でチャネルを使ってデータの送受信や同期を行うことができます。
- go キーワードを使用して、関数やメソッドをゴルーチンとして実行することができます。
- ゴルーチンは、Go 言語で効率的な並行処理を実現するための主要な機能です。

# チャネルとは

チャネル (Channel) は、Go 言語における並行処理のためのデータ構造で、ゴルーチン間でデータの送受信や同期を行うのに使用されます。チャネルは、First-In-First-Out (FIFO) のキューのように動作し、データの送受信が同期されています。これにより、ゴルーチン間で簡単かつ安全にデータのやり取りができます。
